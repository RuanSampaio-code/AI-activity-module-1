<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador de Recursos Alien√≠genas</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #0a0a1a;
            color: #e0e0ff;
            margin: 0;
            padding: 20px;
        }
        
        h1 {
            color: #7e57c2;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(126, 87, 194, 0.5);
        }
        
        .info {
            display: flex;
            justify-content: space-between;
            width: 450px;
            margin-bottom: 20px;
        }
        
        .score, .instructions {
            background-color: rgba(30, 30, 60, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            border: 1px solid #3d3d6b;
        }
        
        .score {
            font-size: 18px;
            font-weight: bold;
            color: #64ffda;
        }
        
        .instructions {
            font-size: 14px;
        }
        
        .game-container {
            background-color: rgba(30, 30, 60, 0.5);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            padding: 20px;
            border: 1px solid #3d3d6b;
        }
        
        .matrix {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            grid-template-rows: repeat(10, 40px);
            gap: 2px;
            background-color: #1a1a2e;
            padding: 10px;
            border-radius: 5px;
        }
        
        .cell {
            width: 40px;
            height: 40px;
            background-color: #16213e;
            border: 1px solid #2a2a4a;
            box-sizing: border-box;
            position: relative;
        }
        
        .resource::after {
            content: "üíé";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
        }
        
        .mountain::after {
            content: "üèîÔ∏è";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
        }
        
        .river::after {
            content: "üåä";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
        }
        
        .base::after {
            content: "üöÄ";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
        }
        
        .agent::after {
            content: "ü§ñ";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            z-index: 10;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .controls-row {
            display: flex;
            margin: 5px 0;
        }
        
        button {
            min-width: 100px;
            height: 40px;
            margin: 0 5px;
            font-size: 16px;
            background-color: #7e57c2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #9575cd;
        }
        
        button:active {
            background-color: #673ab7;
        }
        
        .restart {
            background-color: #e91e63;
        }
        
        .restart:hover {
            background-color: #f06292;
        }
        
        .status {
            margin-top: 10px;
            font-size: 16px;
            color: #64ffda;
        }
        
        .planet-info {
            margin-top: 20px;
            background-color: rgba(30, 30, 60, 0.7);
            padding: 15px;
            border-radius: 5px;
            max-width: 450px;
            text-align: center;
            border: 1px solid #3d3d6b;
        }
        
        .planet-name {
            font-weight: bold;
            color: #7e57c2;
            font-size: 18px;
            margin-bottom: 5px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 15px;
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }
        
        .legend-icon {
            font-size: 20px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <h1>Explorador de Recursos Alien√≠genas</h1>
    
    <div class="info">
        <div class="score">Recursos: <span id="score">0</span></div>
        <div class="instructions">Explora√ß√£o autom√°tica com obst√°culos</div>
    </div>
    
    <div class="game-container">
        <div class="matrix" id="matrix"></div>
    </div>
    
    <div class="controls">
        <div class="controls-row">
            <button id="start">Iniciar Explora√ß√£o</button>
            <button id="pause">Pausar</button>
        </div>
        <button class="restart" id="restart">Nova Explora√ß√£o</button>
        <div class="status" id="status">Aguardando ordens da base...</div>
    </div>
    
    <div class="planet-info">
        <div class="planet-name">Planeta Zircon-9</div>
        <div>Miss√£o: Coletar cristais de zirc√¥nio evitando obst√°culos naturais.</div>
        
        <div class="legend">
            <div class="legend-item">
                <span class="legend-icon">üöÄ</span>
                <span>Base</span>
            </div>
            <div class="legend-item">
                <span class="legend-icon">ü§ñ</span>
                <span>Rob√¥</span>
            </div>
            <div class="legend-item">
                <span class="legend-icon">üíé</span>
                <span>Cristal</span>
            </div>
            <div class="legend-item">
                <span class="legend-icon">üèîÔ∏è</span>
                <span>Montanha</span>
            </div>
            <div class="legend-item">
                <span class="legend-icon">üåä</span>
                <span>Rio</span>
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√µes do jogo
        const matrixSize = 10;
        const resourceCount = 15;
        const mountainCount = 8;
        const riverCount = 10;
        const pointsPerResource = 5;
        const moveSpeed = 300; // Velocidade de movimento em ms
        
        // Estado do jogo
        let matrix = [];
        let agentPosition = { x: 0, y: 0 };
        let score = 0;
        let movementInterval = null;
        let isMoving = false;
        let movingRight = true; // Dire√ß√£o inicial (direita)
        let pathFindingMode = false;
        let targetPosition = null;
        
        // Elementos do DOM
        const matrixElement = document.getElementById('matrix');
        const scoreElement = document.getElementById('score');
        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('start');
        const pauseButton = document.getElementById('pause');
        const restartButton = document.getElementById('restart');
        
        // Inicializar o jogo
        function initGame() {
            // Parar movimento se estiver em andamento
            stopMovement();
            
            // Resetar estado
            matrix = [];
            agentPosition = { x: 0, y: 0 };
            score = 0;
            scoreElement.textContent = score;
            statusElement.textContent = "Aguardando ordens da base...";
            movingRight = true;
            pathFindingMode = false;
            targetPosition = null;
            
            // Limpar matriz
            matrixElement.innerHTML = '';
            
            // Criar matriz vazia
            for (let y = 0; y < matrixSize; y++) {
                const row = [];
                for (let x = 0; x < matrixSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    matrixElement.appendChild(cell);
                    row.push({ 
                        hasResource: false, 
                        isMountain: false,
                        isRiver: false,
                        isBase: false,
                        element: cell 
                    });
                }
                matrix.push(row);
            }
            
            // Colocar a base no ponto inicial
            matrix[0][0].isBase = true;
            matrix[0][0].element.classList.add('base');
            
            // Posicionar obst√°culos aleatoriamente
            placeObstacles();
            
            // Posicionar recursos aleatoriamente
            placeResources();
            
            // Posicionar o agente
            updateAgentPosition();
        }
        
        // Posicionar obst√°culos aleatoriamente
        function placeObstacles() {
            // Colocar montanhas
            let mountainsPlaced = 0;
            while (mountainsPlaced < mountainCount) {
                const x = Math.floor(Math.random() * matrixSize);
                const y = Math.floor(Math.random() * matrixSize);
                
                // N√£o colocar montanha na base ou onde j√° tem obst√°culo
                if ((x !== 0 || y !== 0) && 
                    !matrix[y][x].isMountain && 
                    !matrix[y][x].isRiver) {
                    matrix[y][x].isMountain = true;
                    matrix[y][x].element.classList.add('mountain');
                    mountainsPlaced++;
                }
            }
            
            // Colocar rios
            let riversPlaced = 0;
            while (riversPlaced < riverCount) {
                const x = Math.floor(Math.random() * matrixSize);
                const y = Math.floor(Math.random() * matrixSize);
                
                // N√£o colocar rio na base ou onde j√° tem obst√°culo
                if ((x !== 0 || y !== 0) && 
                    !matrix[y][x].isMountain && 
                    !matrix[y][x].isRiver) {
                    matrix[y][x].isRiver = true;
                    matrix[y][x].element.classList.add('river');
                    riversPlaced++;
                }
            }
        }
        
        // Posicionar recursos aleatoriamente
        function placeResources() {
            let resourcesPlaced = 0;
            
            while (resourcesPlaced < resourceCount) {
                const x = Math.floor(Math.random() * matrixSize);
                const y = Math.floor(Math.random() * matrixSize);
                
                // N√£o colocar recurso onde o agente est√°, na base ou em obst√°culos
                if ((x !== agentPosition.x || y !== agentPosition.y) && 
                    !matrix[y][x].hasResource && 
                    !matrix[y][x].isMountain && 
                    !matrix[y][x].isRiver &&
                    !matrix[y][x].isBase) {
                    matrix[y][x].hasResource = true;
                    matrix[y][x].element.classList.add('resource');
                    resourcesPlaced++;
                }
            }
        }
        
        // Verificar se uma posi√ß√£o √© v√°lida para movimento
        function isValidMove(x, y) {
            return x >= 0 && x < matrixSize && 
                   y >= 0 && y < matrixSize && 
                   !matrix[y][x].isMountain && 
                   !matrix[y][x].isRiver;
        }
        
        // Atualizar a posi√ß√£o do agente na matriz
        function updateAgentPosition() {
            // Remover classe 'agent' de todas as c√©lulas
            document.querySelectorAll('.agent').forEach(cell => {
                cell.classList.remove('agent');
            });
            
            // Adicionar classe 'agent' √† c√©lula atual
            matrix[agentPosition.y][agentPosition.x].element.classList.add('agent');
            
            // Verificar se h√° recurso na posi√ß√£o atual
            if (matrix[agentPosition.y][agentPosition.x].hasResource) {
                collectResource();
            }
        }
        
        // Coletar recurso
        function collectResource() {
            // Remover recurso da posi√ß√£o atual
            matrix[agentPosition.y][agentPosition.x].hasResource = false;
            matrix[agentPosition.y][agentPosition.x].element.classList.remove('resource');
            
            // Atualizar pontua√ß√£o
            score += pointsPerResource;
            scoreElement.textContent = score;
            
            // Verificar se todos os recursos foram coletados
            checkMissionCompletion();
        }
        
        // Verificar se todos os recursos foram coletados
        function checkMissionCompletion() {
            let remainingResources = 0;
            
            for (let y = 0; y < matrixSize; y++) {
                for (let x = 0; x < matrixSize; x++) {
                    if (matrix[y][x].hasResource) {
                        remainingResources++;
                    }
                }
            }
            
            if (remainingResources === 0) {
                stopMovement();
                statusElement.textContent = "Miss√£o completa! Todos os recursos coletados.";
                setTimeout(() => {
                    alert(`Miss√£o completa! Voc√™ coletou todos os cristais de zirc√¥nio e obteve ${score} pontos!`);
                }, 300);
            }
        }
        
        // Encontrar pr√≥xima posi√ß√£o v√°lida
        function findNextValidPosition() {
            const directions = [
                { dx: 1, dy: 0 },  // direita
                { dx: 0, dy: 1 },  // baixo
                { dx: -1, dy: 0 }, // esquerda
                { dx: 0, dy: -1 }  // cima
            ];
            
            // Priorizar dire√ß√£o atual de movimento
            if (movingRight) {
                // Priorizar direita, depois baixo, depois esquerda, depois cima
                directions.sort((a, b) => {
                    if (a.dx === 1) return -1;
                    if (b.dx === 1) return 1;
                    if (a.dy === 1) return -1;
                    if (b.dy === 1) return 1;
                    return 0;
                });
            } else {
                // Priorizar esquerda, depois baixo, depois direita, depois cima
                directions.sort((a, b) => {
                    if (a.dx === -1) return -1;
                    if (b.dx === -1) return 1;
                    if (a.dy === 1) return -1;
                    if (b.dy === 1) return 1;
                    return 0;
                });
            }
            
            // Tentar cada dire√ß√£o
            for (const dir of directions) {
                const newX = agentPosition.x + dir.dx;
                const newY = agentPosition.y + dir.dy;
                
                if (isValidMove(newX, newY)) {
                    return { x: newX, y: newY };
                }
            }
            
            // Se n√£o encontrar movimento v√°lido
            return null;
        }
        
        // Movimento autom√°tico do agente
        function moveAgent() {
            if (!isMoving) return;
            
            let newPosition;
            
            if (pathFindingMode) {
                // Modo de busca de caminho quando encontra obst√°culo
                newPosition = findNextValidPosition();
                
                if (newPosition) {
                    // Se encontrou um caminho v√°lido
                    if (newPosition.x > agentPosition.x) {
                        movingRight = true;
                    } else if (newPosition.x < agentPosition.x) {
                        movingRight = false;
                    }
                    
                    // Verificar se voltamos ao padr√£o normal de varredura
                    if ((movingRight && newPosition.x > agentPosition.x) || 
                        (!movingRight && newPosition.x < agentPosition.x)) {
                        pathFindingMode = false;
                    }
                } else {
                    // N√£o h√° caminho v√°lido
                    stopMovement();
                    statusElement.textContent = "Caminho bloqueado! Explora√ß√£o interrompida.";
                    return;
                }
            } else {
                // Movimento normal em zigue-zague
                newPosition = { ...agentPosition };
                
                if (movingRight) {
                    // Movendo para a direita
                    if (newPosition.x < matrixSize - 1 && isValidMove(newPosition.x + 1, newPosition.y)) {
                        newPosition.x++;
                    } else {
                        // Obst√°culo ou fim da linha, tentar descer
                        if (newPosition.y < matrixSize - 1 && isValidMove(newPosition.x, newPosition.y + 1)) {
                            newPosition.y++;
                            movingRight = false;
                        } else {
                            // N√£o pode descer, entrar em modo de busca de caminho
                            pathFindingMode = true;
                            return moveAgent(); // Chamar recursivamente para usar o modo de busca
                        }
                    }
                } else {
                    // Movendo para a esquerda
                    if (newPosition.x > 0 && isValidMove(newPosition.x - 1, newPosition.y)) {
                        newPosition.x--;
                    } else {
                        // Obst√°culo ou in√≠cio da linha, tentar descer
                        if (newPosition.y < matrixSize - 1 && isValidMove(newPosition.x, newPosition.y + 1)) {
                            newPosition.y++;
                            movingRight = true;
                        } else {
                            // N√£o pode descer, entrar em modo de busca de caminho
                            pathFindingMode = true;
                            return moveAgent(); // Chamar recursivamente para usar o modo de busca
                        }
                    }
                }
            }
            
            // Atualizar posi√ß√£o do agente
            if (newPosition) {
                agentPosition = newPosition;
                updateAgentPosition();
            } else {
                // N√£o h√° movimento poss√≠vel
                stopMovement();
                statusElement.textContent = "Explora√ß√£o interrompida. Terreno inacess√≠vel.";
            }
        }
        
        // Iniciar movimento autom√°tico
        function startMovement() {
            if (!isMoving) {
                isMoving = true;
                statusElement.textContent = "Explorando o planeta...";
                movementInterval = setInterval(moveAgent, moveSpeed);
            }
        }
        
        // Parar movimento autom√°tico
        function stopMovement() {
            if (isMoving) {
                isMoving = false;
                clearInterval(movementInterval);
                statusElement.textContent = "Explora√ß√£o pausada.";
            }
        }
        
        // Event listeners para os bot√µes
        startButton.addEventListener('click', startMovement);
        pauseButton.addEventListener('click', stopMovement);
        restartButton.addEventListener('click', initGame);
        
        // Iniciar o jogo
        initGame();
    </script>
</body>
</html>